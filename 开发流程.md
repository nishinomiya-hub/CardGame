# 卡牌游戏开发流程

## 第一阶段：项目基础架构搭建

### 1.1 创建基础目录结构

Classes/
├── configs/ # 静态配置相关类
│ ├── models/ # 配置数据模型
│ └── loaders/ # 配置加载器
├── models/ # 运行时动态数据模型
├── views/ # 视图层，UI展示组件
├── controllers/ # 控制器层，协调模型和视图
├── managers/ # 管理器层，提供全局服务
├── services/ # 服务层，处理业务逻辑
└── utils/ # 工具类


### 1.2 设计数据模型（models层）
- **CardModel**：卡牌数据模型
  - 卡牌ID、花色、点数、位置状态、是否可见等属性
- **GameModel**：游戏数据模型  
  - 手牌区卡牌列表、桌面牌区卡牌列表、当前顶部牌引用
- **UndoModel**：回退数据模型
  - 操作类型、源卡牌、目标卡牌、操作前状态、操作后状态

## 第二阶段：配置系统开发（configs层）

### 2.1 卡牌资源配置
- **CardResConfig**：定义每张卡牌对应的图片资源路径
- **CardResConfigLoader**：加载卡牌资源配置

### 2.2 游戏关卡配置
- **LevelConfig**：定义关卡初始布局
- **LevelConfigLoader**：加载关卡配置

## 第三阶段：视图层开发（views层）

### 3.1 CardView开发
- 继承cocos2d::Sprite
- 实现卡牌显示、触摸事件处理
- 提供根据卡牌ID显示的接口：`displayCard(int cardId)`
- 提供移动动画接口：`playMoveAnimation()`

### 3.2 区域视图开发
- **StackView**：手牌区视图，管理手牌显示布局
- **PlayFieldView**：桌面牌区视图，管理桌面牌布局  
- **GameView**：主游戏视图，整合所有UI元素

## 第四阶段：服务层开发（services层）

### 4.1 游戏数据生成服务
- **GameModelFromLevelGenerator**
  - 根据LevelConfig生成初始GameModel
  - 处理卡牌随机生成逻辑

### 4.2 卡牌匹配服务
- **CardMatchService**
  - 提供静态方法验证两张牌是否匹配（点数差1）
  - 纯逻辑判断，不持有数据

## 第五阶段：管理器开发（managers层）

### 5.1 回退管理器
- **UndoManager**
  - 维护操作历史栈（vector<UndoModel>）
  - 提供记录操作和执行回退方法

## 第六阶段：控制器层开发（controllers层）

### 6.1 游戏主控制器
- **GameController**
  - 持有GameModel、GameView、各子控制器
  - 管理游戏生命周期

### 6.2 区域控制器
- **StackController**：处理手牌区逻辑
- **PlayFieldController**：处理桌面牌区逻辑

## 第七阶段：实现核心功能流程

### 7.1 游戏初始化流程

用户选择关卡 → GameController.startGame(levelId)
→ 加载LevelConfig
→ GameModelFromLevelGenerator生成GameModel
→ 初始化各控制器和视图
→ 设置初始UI布局


### 7.2 需求1：手牌区翻牌替换实现
用户点击手牌区CardView
→ CardView触发触摸事件
→ 回调StackController.handleCardClick(cardId)
→ StackController验证点击合法性
→ UndoManager.recordOperation()记录当前状态
→ 更新GameModel：调整手牌顺序
→ StackView.playCardMoveAnimation()播放移动动画


### 7.3 需求2：桌面牌匹配实现  

用户点击桌面CardView
→ CardView触发触摸事件
→ 回调PlayFieldController.handleCardClick(cardId)
→ 通过CardMatchService验证与手牌顶部牌是否匹配
→ 如果匹配：UndoManager.recordOperation()记录状态
→ 更新GameModel：移除桌面牌，设置为新手牌顶部
→ 播放移动动画


### 7.4 需求3：回退功能实现

用户点击回退按钮
→ GameController.handleUndo()
→ UndoManager.undo()获取上一步操作
→ 根据UndoModel恢复GameModel状态
→ 各View播放反向移动动画
→ 重复直到无记录可回退


## 第八阶段：具体实现要点

### 8.1 动画实现
- 使用`MoveTo`实现卡牌平移
- 动画完成后需要更新视图状态
- 回退时播放反向动画

### 8.2 触摸事件处理
- 在CardView中处理触摸事件
- 通过回调函数通知Controller
- Controller处理业务逻辑后更新Model和View

### 8.3 数据一致性
- 任何操作都要先更新Model再更新View
- 回退操作要完全还原操作前的状态
- 动画只是视觉表现，真实状态以Model为准

## 第九阶段：测试和调试

### 9.1 功能测试
- 测试手牌区点击替换功能
- 测试桌面牌匹配功能  
- 测试连续回退功能
- 测试边界情况

### 9.2 性能测试
- 测试大量卡牌时的性能
- 测试连续快速操作时的稳定性

## 编码规范

### 命名规范
- 类名和文件名：大写字母开头
- 函数名和变量名：驼峰风格（小写字母开头）
- 私有成员：以 `_` 下划线开头
- 常量：以 `k` 开头

### 代码质量要求
- 每个类必须添加详细注释
- 函数代码不超过50行
- 类代码不超过500行
- 遵循单一职责原则